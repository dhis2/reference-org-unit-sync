- routeTemplate:
    id: metadataSubscriberRouteTemplate
    route:
      description: |
        Routes the captured change to the corresponding route. This route template is materialised into a route for each 
        target resulting in a subscriber per target.
      routeConfigurationId: deadLetterQueueRouteConfig
      from:
        description: |
          Consumes the captured changes from a multicast queue. This endpoint registers itself as a durable subscriber so 
          that published changes are not lost in the event this consumer is offline. Thanks to `acknowledgementModeName` 
          being set to `CLIENT_ACKNOWLEDGE`, the captured change is not formally consumed until the synchronisation has 
          been processed.
        uri: jms:topic:metadata
        parameters:
          clientId: "{{clientId}}"
          durableSubscriptionName: OrgUnitSyncConsumer
          acknowledgementModeName: CLIENT_ACKNOWLEDGE
          maxConcurrentConsumers: 1
        steps:
          - setVariable:
              description: Assigns the metadata resource ID to a variable.
              name: id
              header: id
          - setVariable:
              description: |
                Inserts the target parameters into a `java.util.Map` object and assigns the object to a variable.
              name: target
              groovy: |
                [
                  'index': '{{index}}',
                  'dhis2ApiUrl': '{{dhis2ApiUrl}}',       
                  'dhis2ApiUsername': '{{dhis2ApiUsername:}}',               
                  'dhis2ApiPassword': '{{dhis2ApiPassword:}}',    
                  'personalAccessToken': '{{personalAccessToken:}}',               
                  'idScheme': '{{idScheme:uid}}',
                  'camelDirectEndpointName': '{{camelDirectEndpointName}}',
                  'fieldsRequireApproval': '{{fieldsRequireApproval}}',
                  'messageConversationUserId': '{{messageConversationUserId}}',
                  'allowedOperations': '{{allowedOperations}}',
                  'resourceMap.file': '{{resourceMap.file:}}'
                ]
          - toD:
              description: |
                Dynamically sends the captured change to a route based on the name of the source table.
              uri: direct:${headers.DebeziumSourceTable}

- route:
    id: syncChangeRoute
    description: |
      Pre-processes the metadata import payload, if it is not a delete operation, and sends the message to either one 
      of following routes:
        (a) a route responsible for implementing the sync approval workflow
        (b) a route that executes the sync operation on the target DHIS2 server
    routeConfigurationId: deadLetterQueueRouteConfig
    from:
      uri: direct:sync
      steps:
        - filter:
            description: Filters out sync operations that are not included in the `DebeziumOperation` header.
            groovy: variables.target.allowedOperations.split(',').contains(headers.DebeziumOperation)
        - to:
            description: Applies any mappings to the metadata import payload.
            uri: direct:map
        - to:
            description: Receives a result from the route and assigns it to a variable.
            uri: direct:checkPendingApproval
            variableReceive: isPendingApproval
        - choice:
            description: |
              Evaluates whether the sync should be manually approved depending on the `target.[n].fieldsRequireApproval` 
              property and any pending approvals.
            when:
              - groovy: |
                  fieldsRequireApproval = variables.target.fieldsRequireApproval.split(',') as List
                  updatedApprovalFields = fieldsRequireApproval.intersect(headers.DebeziumDiff.split(',') as List)
                  exchange.setVariable('updatedApprovalFields', updatedApprovalFields)
                  variables.isPendingApproval || !updatedApprovalFields.isEmpty()
                steps:
                  - to: direct:sendSyncApprovalRequest
            otherwise:
              steps:
                - toD: direct:${variables.target['camelDirectEndpointName']}

- route:
    id: checkPendingApprovalRoute
    description: Sets the message body to true if the target server has pending approvals, otherwise sets it to false.
    routeConfigurationId: deadLetterQueueRouteConfig
    from:
      uri: direct:checkPendingApproval
      steps:
        - setBody:
            simple: ${null}
        - doTry:
            steps:
              - toD:
                  description: Fetches the draft metadata import from the target DHIS2 data store.
                  uri: dhis2:get/resource
                  parameters:
                    path: dataStore/org-unit-sync
                    baseApiUrl: ${variables.target['dhis2ApiUrl']}
                    username: ${variables.target['dhis2ApiUsername']}
                    password: ${variables.target['dhis2ApiPassword']}
                    personalAccessToken: ${variables.target['personalAccessToken']}
              - log:
                  loggingLevel: WARN
                  message: > 
                   One or more pending approvals found on target server [${variables.target['dhis2ApiUrl']}].
                   Resource [${variables.id}] will not be synced until all pending synchronisations have been approved
                   or deleted from the target DHIS2 data store
              - setBody:
                  groovy: true
              - doCatch:
                  exception:
                    - org.hisp.dhis.integration.sdk.api.RemoteDhis2ClientException
                  onWhen:
                    simple: ${exception.cause.httpStatusCode} == 404
                  steps:
                    - setBody:
                        groovy: false

- route:
    id: mapRoute
    from:
      uri: direct:map
      steps:
        - filter:
            description: Filters out delete sync operations since a delete operation does not import data.
            simple: ${headers.DebeziumOperation} != 'd'
        - setVariable:
            description: |
              Stashes temporarily away the metadata import payload in order to store the mapping file inside the body.
            name: metadataImport
            simple: ${body}
        - setBody:
            description: |
              Attempts to read the mapping CSV file as set from `target.[n].resourceMap.file` or defaults to empty text.
            groovy: "variables.target['resourceMap.file'] ? new File(variables.target['resourceMap.file']).text : ''"
        - unmarshal:
            description: Deserialises the mapping CSV file into a list of maps.
            csv:
              captureHeaderRecord: true
              useOrderedMaps: true
        - setVariable:
            description: |
              Assigns the CSV column name prefixed with 'source_' to a variable. 
            name: matchOnColumnName
            groovy: "headers.CamelCsvHeaderRecord.find{it.startsWith('source_')} ?: 'source_null'"
        - setVariable:
            description: Pulls out from the metadata import payload a value that has its field name matching the CSV source column name.
            name: matchOnResult
            groovy: |
              if (body.isEmpty()) return ''
              exp = camelContext.resolveLanguage('jsonpath').createExpression("\$.*[0].${variables.matchOnColumnName - 'source_'}")
              exp.setResultType(String.class)
              exp.evaluate(org.apache.camel.builder.ExchangeBuilder.anExchange(camelContext).withBody(variables.metadataImport).build(), String.class)
        - transform:
            description: Transforms the mappings into a JQ expression.
            groovy: |
              rules = { body.findAll { it[variables.matchOnColumnName] == variables.matchOnResult}.collect { map ->
                map.findAll { it.key != variables.matchOnColumnName}.collect { k, v -> 
                  """.[0].value[0].$k = "$v" """ 
                  }.join(' | ')
              }[0] }      
              """to_entries | (if .[0].value[0].${variables.matchOnColumnName - 'source_'} == "${variables.matchOnResult}" then ${rules() ?: '.'} else . end) | from_entries"""
        - setVariable:
            description: Assigns a variable the JQ expression for mapping fields.
            name: jqExpression
            simple: ${body}
        - setBody:
            description: Restores the body to the metadata import payload.
            variable: metadataImport
        - transform:
            description: Applies the JQ expression on the metadata import payload.
            groovy: camelContext.resolveLanguage('jq').createExpression(variables.jqExpression).evaluate(exchange, String.class)